* Challenge 1
  - Converting hex to base64
  #+BEGIN_SRC python :session :results value
    from base64 import b64decode, b64encode
    import codecs


    def hex2b64(s):
        s = codecs.decode(s, "hex")
        return codecs.decode((b64encode(s)), "ascii")


    def test_hex2b64():
        s = "49276d206b696c6c696e6720796f757220627261696e206c696b65206120706f69736f6e6f7573206d757368726f6f6d"
        t = "SSdtIGtpbGxpbmcgeW91ciBicmFpbiBsaWtlIGEgcG9pc29ub3VzIG11c2hyb29t"
        return t == hex2b64(s)


    test_hex2b64()
  #+END_SRC

  #+RESULTS:
  : True

* Challenge 2
  - Producing the XOR of two fixed-length strings
  - Always operating with bytes, using hex strings only for presentation
  #+BEGIN_SRC python :session :results value
    import codecs


    def xor_strings(xs, ys):
        return bytes([x ^ y for x, y in zip(xs, ys)])


    def test_xor_strings():
        xs = codecs.decode("1c0111001f010100061a024b53535009181c", "hex")
        ys = codecs.decode("686974207468652062756c6c277320657965", "hex")
        zs = codecs.decode("746865206b696420646f6e277420706c6179", "hex")
        return zs == xor_strings(xs, ys)

    text_xor_strings()
  #+END_SRC

  #+RESULTS:

* Challenge 3
  - Decrypt a single byte XOR encrypted message
  - The standard frequencies are taken from [[https://www.wikiwand.com/en/Letter_frequency#/Relative_frequencies_of_letters_in_the_English_language][here]] 
  - Similarity measure is the negative of the distance measure taken from [[https://www.wikiwand.com/en/Bhattacharyya_distance][here]] 
  #+BEGIN_SRC python :session :results value
    import codecs
    import string
    from collections import Counter, defaultdict
    from math import log, sqrt

    n = 1

    def compute_ngram_freqs(n=1):
        p = bytes(''.join(open("pride.txt").readlines()).lower(), 'utf-8')
        bis = [p[i:i+n] for i in range(len(p)-n)]
        top = Counter(bis).most_common(500)
        freqs = defaultdict(lambda: float('-inf'))
        for b, c in top:
            freqs[b] = float(c) / len(bis)
        return freqs


    freqs = compute_ngram_freqs(n)


    def english_similarity(m, n=1):
        score = 0
        m = m.lower()
        test_counts = Counter([m[i:i+n] for i in range(len(m)-n)])
        total_ngrams = sum(test_counts.values())
        for bi in test_counts.keys():
            test_freq = float(test_counts[bi]) / total_ngrams
            score += sqrt(test_freq * freqs[bi])
        if score == 0 or score == float('-inf'):
            return float('-inf')
        else:
            return log(score)


    def decrypt_single_byte_xor(s):
        plain = ""
        score = float('-inf')
        for c in range(256):
            key = [c] * len(s)
            candidate = xor_strings(key, s)
            candidate_score = english_similarity(candidate, 1)
            if candidate_score > score:
                score = candidate_score
                plain = candidate
                print(score, plain)
        return plain, score


    def test_decrypt_single_byte_xor():
        s = codecs.decode("1b37373331363f78151b7f2b783431333d78397828372d363c78373e783a393b3736", "hex")
        plain = codecs.encode("Cooking MC's like a pound of bacon")
        return decrypt_single_byte_xor(s)[0] == plain


    test_decrypt_single_byte_xor()
  #+END_SRC

  #+RESULTS:

* Challenge 4
  - The file "4.txt" has 60 strings, of which one is single-byte XOR encrypted. We need to find it.
  - Reusing the ~english_similarity~ code from the previous challenge, pick the string with the highest candidate similarity.
  #+BEGIN_SRC python :session :results value
    import codecs
    from operator import itemgetter


    def find_single_byte_xor(lines):
        lines = map(decrypt_single_byte_xor, lines)
        return max(lines, key=itemgetter(1))


    def test_find_single_byte_xor():
        lines = open("4.txt").readlines()
        lines = map(lambda x: codecs.decode(x.strip(), "hex"), lines)
        return find_single_byte_xor(lines)

    print(test_find_single_byte_xor())
  #+END_SRC

  #+RESULTS:

* Challenge 5
  - Implement repeating-key XOR
  #+BEGIN_SRC python :session :results value
    import codecs


    def repeating_key_xor(key, plain):
        key = key * (len(plain) // len(key)) + key[:(len(plain) % len(key))]
        return xor_strings(key, plain)


    def test_repeating_key_xor():
        plain = codecs.encode('''Burning 'em, if you ain't quick and nimble
    I go crazy when I hear a cymbal''')
        key = codecs.encode("ICE")
        cipher = codecs.decode('''0b3637272a2b2e63622c2e69692a23693a2a3c6324202d623d63343c2a26226324272765272a282b2f20430a652e2c652a3124333a653e2b2027630c692b20283165286326302e27282f''', "hex")
        return repeating_key_xor(key, plain) == cipher

    test_repeating_key_xor()
  #+END_SRC

  #+RESULTS:
  : True

* Challenge 6
  - Break repeating-key XOR
  - The file "6.txt" has a string that was encrypted with repeating-key XOR and then base64 encoded.
  - Guess the key-length by computing hamming distances between candidate length sized blocks and testing the candidate lengths with the smallest average hamming distances between blocks.
    - We average hamming distances between 4 blocks, normalize by dividing by the candidate keysize, and then use the five keysizes with the least normalized average hamming distances as candidate keysizes.
  - Given the keysize, breaking the ciphertext into blocks and taking the transpose gives you a bunch of single-byte xor problems to solve, the results of which should produce the original key.

#+BEGIN_SRC python :session :results value
  import codecs
  from operator import itemgetter
  from base64 import b64decode


  def hamming(xs, ys):
      return sum(bin(x ^ y).count("1") for x, y in zip(xs, ys))


  def test_hamming():
      xs = codecs.encode("this is a test")
      ys = codecs.encode("wokka wokka!!!")
      return hamming(xs, ys) == 37


  test_hamming()


  def guess_keysize(ciphertext):
      keysize_weights = []
      for n in range(1, 64):
          a, b, c, d = (ciphertext[:n], ciphertext[n:2*n],
                        ciphertext[2*n:3*n], ciphertext[3*n:4*n])
          h = (hamming(a, b) + hamming(b, c) + hamming(c, d) +
               hamming(a, c) + hamming(a, d) + hamming(b, d)) / 6 / n
          keysize_weights.append((n, h))
      return list(map(itemgetter(0),
                      sorted(keysize_weights,
                             key=itemgetter(1))))[:5]

  def decrypt_repeated_key_xor():
      ciphertext = b64decode("".join(open("6.txt").readlines()))
      guesses = guess_keysize(ciphertext)
      candidates = []
      for ks in guesses:
          blocks = [ciphertext[i:i+ks] for i in range(len(ciphertext) - ks)]
          trans = [bytes(blocks[i][j] for i in range(len(blocks)))
                   for j in range(ks)]
          trans_plains = list(map(decrypt_single_byte_xor, trans))
          trans_plains = list(map(itemgetter(0), trans_plains))
          plaintext = b"".join(bytes(trans_plains[i][j] for i in range(ks))
                               for j in range(len(blocks)))
          print(plaintext[:50])
          candidates.append(plaintext)
      return max(candidates, key=english_similarity)

  a = decrypt_repeated_key_xor()
#+END_SRC

#+RESULTS:
: True
